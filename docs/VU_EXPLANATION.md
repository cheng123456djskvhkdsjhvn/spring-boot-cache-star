# VU（Virtual User）虚拟用户详解

## 📚 什么是 VU？

**VU = Virtual User（虚拟用户）**

在负载测试中，VU 代表一个**模拟的用户**，它会按照测试脚本执行一系列操作（比如发送 HTTP 请求）。

---

## 🎯 VU 的作用

### 1. **模拟真实用户行为**

每个 VU 就像是一个真实的用户：
- 发送 HTTP 请求
- 等待响应
- 执行检查（验证响应是否正确）
- 可能有一些延迟（sleep）

### 2. **控制并发压力**

通过控制 VU 的数量，可以模拟不同规模的用户访问：
- **10 个 VU** = 模拟 10 个用户同时访问
- **200 个 VU** = 模拟 200 个用户同时访问
- **1000 个 VU** = 模拟 1000 个用户同时访问

---

## 📊 VU 与 QPS 的关系

### 基本公式

```
QPS ≈ VU数量 × 每个VU每秒的请求数
```

### 实际例子

假设你的测试脚本：

```javascript
export default function () {
  http.get('http://localhost:8081/api/hot?id=1');
  sleep(0.1); // 每个请求后等待0.1秒
}
```

**计算过程**：
1. 每个 VU 执行一次请求需要：请求时间 + 0.1秒等待
2. 假设请求耗时 5ms，那么每个 VU 完成一次循环需要：5ms + 100ms = 105ms
3. 每个 VU 每秒可以执行：1000ms ÷ 105ms ≈ 9.5 次请求
4. **200 个 VU** 的 QPS = 200 × 9.5 ≈ **1,900 QPS**

### 如果移除 sleep

```javascript
export default function () {
  http.get('http://localhost:8081/api/hot?id=1');
  // 没有 sleep，VU 会尽可能快地发送请求
}
```

**计算过程**：
1. 每个 VU 执行一次请求需要：请求时间（假设 5ms）
2. 每个 VU 每秒可以执行：1000ms ÷ 5ms = 200 次请求
3. **200 个 VU** 的 QPS = 200 × 200 = **40,000 QPS**（理论值）

**注意**：实际 QPS 会受到以下因素限制：
- 服务器处理能力
- 网络带宽
- 客户端（k6）的发送能力
- 系统资源（CPU、内存）

---

## 🔄 VU 的生命周期

### 1. **启动阶段（Ramp-up）**

```
阶段1: 20秒内从 0 增加到 50 个 VU
阶段2: 30秒内从 50 增加到 100 个 VU
阶段3: 30秒内从 100 增加到 150 个 VU
阶段4: 30秒内从 150 增加到 200 个 VU
```

**为什么需要逐步增加？**
- 避免突然的高并发导致系统崩溃
- 观察系统在不同负载下的表现
- 更接近真实的用户访问模式（用户不会同时上线）

### 2. **稳定阶段（Sustained Load）**

```
阶段5: 保持 200 个 VU 运行 30 秒
```

在这个阶段，系统承受稳定的负载，可以观察：
- 平均响应时间
- 错误率
- 资源使用情况

### 3. **下降阶段（Ramp-down）**

```
阶段6: 30秒内从 200 降回 0 个 VU
```

逐步减少负载，观察系统恢复情况。

---

## 📈 你的测试配置解析

```javascript
export const options = {
  stages: [
    { duration: '20s', target: 50 },   // 20秒内增加到50个VU
    { duration: '30s', target: 100 },  // 30秒内增加到100个VU
    { duration: '30s', target: 150 },  // 30秒内增加到150个VU
    { duration: '30s', target: 200 },  // 30秒内增加到200个VU
    { duration: '30s', target: 200 },  // 保持200个VU运行30秒
    { duration: '30s', target: 0 },    // 30秒内降回0个VU
  ],
};
```

### 时间线

```
时间轴：
0s ──→ 20s ──→ 50s ──→ 80s ──→ 110s ──→ 140s ──→ 170s
│      │       │       │        │        │        │
0 VU   50 VU   100 VU  150 VU   200 VU   200 VU   0 VU
       ↑       ↑       ↑        ↑        ↑        ↑
     启动    增加    增加     稳定     稳定     停止
```

---

## 💡 VU 与线程/进程的区别

### k6 中的 VU

- **不是线程**：k6 使用 Go 的 goroutine（轻量级协程）
- **不是进程**：所有 VU 在同一个进程中运行
- **协程**：非常轻量，可以创建成千上万个 VU

### 为什么 k6 可以支持大量 VU？

- Go 的 goroutine 非常轻量（几 KB 内存）
- 一个进程可以运行数万个 goroutine
- 比传统的线程池模型（如 JMeter）更高效

---

## 🎯 如何选择合适的 VU 数量？

### 1. **根据目标 QPS 计算**

```
目标 QPS = 12,000
每个 VU 的 QPS = 60（假设每个请求 16.67ms，无 sleep）

需要的 VU 数 = 12,000 ÷ 60 = 200 个 VU
```

### 2. **根据真实用户数**

- 如果系统有 1000 个并发用户，可以设置 1000 个 VU
- 但要注意：VU 不是真实用户，它只是模拟请求

### 3. **逐步增加，找到极限**

```
1. 从 50 个 VU 开始
2. 观察响应时间和错误率
3. 逐步增加到 100、200、500...
4. 找到系统性能下降的临界点
```

---

## 🔍 实际例子：你的测试结果

### 测试配置
- **最大 VU**：200 个
- **sleep**：0.1 秒（已移除）
- **实际 QPS**：1,205（之前）→ 应该会更高（移除 sleep 后）

### 分析

**之前（有 sleep 0.1）**：
- 每个 VU 每秒最多 10 个请求
- 200 VU × 10 = 2,000 QPS（理论值）
- 实际 1,205 QPS（受其他因素限制）

**现在（无 sleep）**：
- 每个 VU 可以更快地发送请求
- 200 VU 应该能达到更高的 QPS
- 实际值取决于服务器性能

---

## 📝 总结

| 概念 | 说明 |
|------|------|
| **VU** | Virtual User，虚拟用户 |
| **作用** | 模拟用户发送请求，控制并发压力 |
| **与 QPS 关系** | QPS ≈ VU数量 × 每个VU每秒请求数 |
| **生命周期** | 启动 → 稳定 → 下降 |
| **特点** | 轻量级协程，可以创建大量 VU |

---

## 🔗 相关资源

- [k6 文档 - Virtual Users](https://k6.io/docs/using-k6/scenarios/concepts/virtual-users/)
- [k6 文档 - Scenarios](https://k6.io/docs/using-k6/scenarios/)

